- **TEP**: [81](https://github.com/ton-blockchain/TEPs/pull/5)
- **title**: TON DNS Стандарт
- **статус**: Активна
- **Тип**: Контрактный Интерфейс
- **авторы**: [EmelyanenkoK](https://github.com/EmelyanenkoK), [Tolya](https://github.com/tolya-yanot)
- **создан**: 25.06.2022
- **Заменяет**: -
- \*\*заменено \*\*: -

# Summary

TON DNS - сервис для перевода человеко-читаемых доменных имен (например, `test.ton` или \`mysite.temp. ), в контактных адресах TON, адресов ADNL, используемых службами, работающими в сети TON (например, TON Sites), и так далее.

# Мотивация

Хотя любой человек в принципе может осуществлять такую услугу с помощью TON Blockchain,
полезно иметь такой предопределенный сервис с известным интерфейсом,
используется по умолчанию, когда приложение или служба хочет перевести человеко-читаемые идентификаторы в адреса.

# Инструкция

## Полезные ссылки

1. [Ссылка на смарт-контракты DNS](https://github.com/ton-blockchain/dns-contract)
2. [Аукция DNS](https://dns.ton.org/) ([исходный код](https://github.com/ton-blockchain/dns))
3. [ton.org documentation](https://ton.org/docs/#/web3/dns)
4. Ответы на вопросы о TON DNS (ru) - [1](https://github.com/ton-blockchain/TEPs/commit/4a09bfc737823f09f05dfb7008eec7784543bb2b), [2](https://telegra.ph/Otvety-na-voprosy-o-TON-DNS-kanalu-Investment-kingyru-CHast-2-08-06), [3](https://telegra.ph/Otvety-na-voprosy-o-TON-DNS-kanalu-Investment-kingyru-CHast-3-08-08-09)

# Спецификация

## Доменные имена

TON DNS использует привычные доменные имена, состоящие из **UTF-8** кодированной строки **до 126 байт**, с различными разделами имени домена, разделёнными точками (".").

Байты в диапазоне `0..32` (нулевый символ, контрольные коды и пробел) включительно не допускаются в доменных именах.

Например, `test.ton` и `mysite.temp.ton` являются допустимыми доменами TON DNS.

Технически домены TON чувствительны к регистру, но TON приложения и службы преобразуют все домены в строчные перед выполнением TON DNS поиска для получения нечувствительности к регистру, так что не имеет смысла регистрировать домены не в нижнем регистре.

Заметим, что конкретная реализация смарт-контракта может наложить дополнительные ограничения на имя при создании поддоменов (например, чтобы избежать подобных символов для защиты от фишинга). Но `dnsresolve` get-method должен поддерживать доменные имена в формате, описанном выше.

## Внутреннее представление домена

Во внутреннем плане TON DNS преобразует имена доменов следующим образом. Сначала доменное имя разделено на компоненты, разделенные точными символами `.`. Затем к каждому компоненту добавляются нулевые символы, а все компоненты объединены в обратном порядке. Например, `google.com` становится `com\0google\0`.

## Домен первого уровня

В настоящее время только домены, заканчивающиеся в `.ton`, признаются допустимыми доменами TON DNS.

Это может измениться в будущем. Однако обратите внимание, что определение доменов первого уровня совпадает с областями первого уровня, уже существующими в Интернете, например ". om`или`.to`, потому что затем можно зарегистрировать домен TON `google. om`, развертывать TON сайт там, создать скрытую ссылку на страницу на этом сайте TON от его невинно выглядящего сайта TON и украсть `google. печенье om-файла от неподозреваемых посетителей.

## Разрешение TON DNS доменов

### Root DNS

Во-первых, у **root DNS смарт-контракт** находится проверка значения параметра конфигурации `#4` в недавнем состоянии masterchain. Этот параметр содержит 256-битный адрес умного контракта root DNS внутри masterchain.

### dnsresolve

**Получать метод**

Затем для root DNS используется специальный метод `dnsresolve` с двумя параметрами:

- Первый параметр — это «CellSlice» с битами данных «8n», содержащими внутреннее представление разрешенного домена, где `n` - длина внутреннего представления в байтах (максимум 127).
- Второй параметр является незнакомым 256-битным целым числом, содержащим нужную категорию. Обычно категорией является sha256 хэш строки. Если категория равна нулю, то запрашиваются все категории.

**Получение результата**

Get-method возвращает два значения:

- Первый— «8м», длина (в битах) префикса разрешения внутреннего представления разрешенного домена, `0 < m <= n`.
- Второй — это «Cell» с TON DNS записью для требуемого домена в требуемой категории, или root 'Словарь' с 256-битными неподписанными целыми ключами (категориями) и значениями, равными сериализации соответствующих TON DNS записей.

**Не решено**

Если этот метод получения не удается, поиск TON DNS не удался.

Если домен не может быть разрешен с помощью смарт-контракта root DNS, т.е. если ни один непустой префикс не является допустимым доменом, известный смарт-контракту, то возвращается файл `(0, null)`.

Другими словами, `m = 0` означает, что поиск TON DNS не обнаружил данных для требуемого домена. В этом случае поиск TON DNS также не удался.

**Разрешено**

Если `m = n`, далее второй компонент результата — либо «Cell» с допустимой TON DNS записью для требуемого домена и категории, или `Null`, если нет записи TON DNS для этого домена с этой категорией.

В любом случае процесс урегулирования останавливается, и полученная таким образом TON DNS запись десериализована и необходимая информация (такая, как тип записи и ее параметры, например адрес смарт-контракта или ADNL адрес).

**Частичное решение**

Наконец, если `m < n`, то поиск до сих пор успешен. , но только частичный результат доступен для префикса `m`-байт оригинального внутреннего представления домена.

Вернутся самые длинные префиксы, известные DNS смарт-контракты. Например, попытка найти `mysite.test.ton` (т.е. `ton\0test\0mysite\0` во внутреннем представлении) в умном контракте DNS root может вернуть `8m=72`, что соответствует префиксу `ton\0test\0`, i. , чтобы поддомен `test.ton` в обычном представлении домена.

В этом случае `dnsresolve()` возвращает значение категории `sha256("dns_next_resolver")` для этого префикса, независимо от категории, запрошенной клиентом. По традиции, категория `sha256("dns_next_resolver")` содержит TON DNS запись типа `dns_next_resolver`, , содержащий адрес следующего смарт-контракта resolver (который может находиться в любой другой рабочей цепочке, например basechain).

Если это действительно так, то процесс разрешения продолжается запуском get-метода `dnsresolve` для следующего resolver, с внутренним представлением доменного имени, содержащего только его часть нерешена (если мы искали `ton\0test\0mysite\0`, и префикс `ton\0test\0` был найден root DNS смарт-контрактом, а следующий `dnsresolve` будет вызван `mysite\0` в качестве первого аргумента).

Затем либо следующий resolver смарт-контракт сообщает об ошибке или отсутствии каких-либо записей для нужного домена или префиксов, или получается окончательный результат, или возвращается другой префикс и следующий смарт-контракт резолвера. В последнем случае процесс продолжается одинаково до тех пор, пока не будут решены все оригинальные домены.

**Нулевой символ в начале**

Нулевой символ `\0` в начале запроса представляет "self".

Вызов метода `dnsresolve` с одним null символом `\0` ("." в человеко-читаемой форме) и категорией верен.

В этом случае DNS смарт-контракт может вернуть запрашиваемую категорию(-и) из своих DNS записей.

Например:

`dnsresolve("ton\0test\0mysite\0", 1)` используется для смарт-контракта root DNS.

Результат `8m=64`, соответствующий префиксу `ton\0test` и `dns_next_resolver`.

`dnsresolve("\0mysite\0", 1)` вызывается для DNS смарт-контракта, полученного из записи `dns_next_resolver`.

Результат `8m=56`, соответствующий префиксу `\0mysite`, и `dns_next_resolver`.

`dnsresolve("\0", 1)` вызывается для DNS смарт-контракта, полученного из записи `dns_next_resolver`.

Результат `8m=8`, соответствующий `\0` и ячейке с DNS записью категории 1.

\*\*Вызов `dnsresolve` на смарт-контракте non-root DNS

То же самое с `dnsresolve` в root-DNS смарт-контракте, но первоначальный запрос должен начинаться с нулевого символа, чтобы все типы реализаций вернули правильный результат.

Пример: `dnsresolve("\0test\0mysite\0")`.

Обратите внимание, что это требуется только для первоначального запроса, а не во время рекурсии.

## DNS Smart Contract

Смарт-контракт, реализующий стандарт TON DNS, должен содержать get-метод `dnsresolve`, который работает как описано выше.

## DNS записи

Стандартные категории:

Категория `sha256("dns_next_resolver")` - DNS следующий резолвер, содержит умный контрактный адрес следующего DNS резолвера в схеме `dns_next_resolver`;

Категория `sha256("кошелек")` - TON Wallet, содержит смарт-адрес контракта в схеме `dns_smc_address`;

Категория `sha256("site")` - TON сайт, содержит ADNL адрес в схеме `dns_adnl_address`;

TL-B схема значений DNS записей:

```
proto_http#4854 = Протокол;
Proto_list_nil$0 = ПротоList;

proto_list_next$1 head:Protocol tail:ProtoList = ProtoList;



cap_is_wallet#2177 = SmcCapability;

cap_list_nil$0 = SmcCapList;
cap_list_next$1 голов:SmcCapability tail:SmcCapList = SmcCapList;

dns_smc_address#9fd3 smc_addr:MsgAddressInt flags:(## 8) { flags <= 1 }
  cap_list:flags . 0?SmcCapList = DNSRecord;
dns_next_resolver#ba93 resolver:MsgAddressInt = DNSRecord;
dns_adnl_address#ad01 adnl_addr:bits256 flags:(## 8) { flags <= 1 }
  proto_list:flags . 0?ProtoList = DNSRecord;
dns_storage_address#7473 bag_id:bits256 = DNSRecord;

_ (HashmapE 256 ^DNSRecord) = DNS_RecordSet;
```

# Ничья

Нет

# Обоснование и альтернативы

## Почему домены настолько дорогие?

Без минимальной цены можно купить все 4-буквенные домены (26^4 = ~457000) на несколько десятков тысяч TON. Таким образом, минимальная цена зависит от длины имени домена. Также стоит отметить, что через несколько месяцев минимальная цена на все домены снизится до 100 TON.

## Почему DNS аукцион сжигает монеты?

Если мы не будем сжигать монеты с DNS аукционов, то кому нам понадобится перевод?

## Почему разрешены только домены ASCII?

Если мы поддерживаем UTF-8, то можно создать домены, которые будут выглядеть одинаково, но все же будут разные домены (example.ton и ехал.тон).

## Почему существует resolver для поддоменов?

Возможна реализация любой логики для субдоменов в пользовательском клиентском соглашении.

## Почему домены не покупаются навсегда?

Существует возможность того, что доступ к кошельку, который владеет домен, будет утерян, так что домен будет потерян навсегда. В TON DNS, каждый год требуется продлевать домены, отправляя не менее 0. 05 TON (минимальное количество TONs для обработки сообщения) к контракту.

# Предыдущее искусство

1. [EIP-137](https://eips.ethereum.org/EIPS/eip-137)

# Нерешенные вопросы

Нет

# Будущие возможности

1. Внедрение приватных (зашифрованных) полей

# Список изменений

- 20 Дек 2023 - удаленные неиспользуемые возможности:

  ```
  cap_method_seqno#5371 = Smcability;
  cap_method_pubkey#71f4 = SmcCapability;
  cap_name#ff name:Текст = SmcCapability;
  ```
